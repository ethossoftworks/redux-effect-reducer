# Testing
Testing `redux-effect-reducer` is pretty straightforward. Since all effect creators and effect reducers are pure, it is easy to repeatably test the outputs certain inputs generate.

## Important Note for testing with Node.JS
There are certain browser-only functions that `redux-effect-reducer` uses. If you want to test with Node.JS you will need to add the Node.JS equivalents for the following functions to the global/window object:
* The Effect Logger uses `performance.now()` for timestamps
* Debounce and Throttle effects use `window.setTimeout()` and `window.clearTimeout()`

```typescript
import { performance } from "perf_hooks";
(global as any).performance = performance;
(global as any).window = {
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
}
```

## Effect Equality Comparisons
Since effects are plain objects, they are comparable with a library like `lodash.isequal` which performs a deep comparison of two objects. This works as expected for most effects. However, it is important to note that:

***If you want to be able to compare equality with effects that take functions as parameters, your effect you must use named functions.***

Consider the following example:

```typescript
import isEqual from "lodash.isequal"

function echo(message: string) {
    console.log(message)
}

const effect1 = run(() => echo("Hello")) // Creates a new anonymous function
const effect2 = run(() => echo("Hello")) // Creates a new anonymous function
isEqual(effect1, effect2) // Returns `false`

const effect3 = run(echo, "Hello") // Uses a predefined function
const effect4 = run(echo, "Hello") // Uses a predefined function
isEqual(effect3, effect4) // Returns `true`
```

The first comparison fails because a new anonymous function instance is created with each `run()` invocation. The second comparison succeeds because the function instance is the same. Don't worry, calling functions in the second form is still type safe and provides type hinting. If you know you won't need to compare two effects, the first form is much more convenient.

## Effect Logging
As you may have noticed, `createEffectReducerMiddleware()` can take an optional effect logger as an option parameter. An `EffectLogger` keeps track of all of the effects run from the middleware and stores valuable information for each effect. This is useful for both testing and debugging. You may create your own EffectLogger or use the provided `DefaultEffectLogger`. For more information on the effect logger, view its API documentation [here](api.md#EffectLogger).

## Testing an effect reducer
Testing the effect reducer is as simple as passing state into your effect reducer with an action and testing the returned effect. This makes certain that your reducer is responding to actions correctly.

```typescript
import isEqual from "lodash.isequal"

function myEffectReducer(state, action) {
    switch(action.type) {
        case "MY_ACTION":
            return (state === 1) ? dispatch({ type: "STATE_IS_ONE" }) : dispatch({ type: "STATE_IS_NOT_ONE" })
    }
}

let actual = myEffectReducer(1, { type: "MY_ACTION" })
let expected = dispatch({ type: "STATE_IS_ONE" })
if (effect === undefined || !isEqual(actual, expected)) {
    fail("Effect reducer returned wrong effect")
}

let actual = myEffectReducer(0, { type: "MY_ACTION" })
let expected = dispatch({ type: "STATE_IS_NOT_ONE" })
if (effect === undefined || !isEqual(actual, expected)) {
    fail("Effect reducer returned wrong effect")
}
```

## Testing an effect
You may test an effect in one of two ways:
1. Use `runEffect()`
2. Use a full store implementation and observe the effects

### Testing with `runEffect()`
To test with `runEffect()` you first need to create a `MiddlewareContext`. This context allows the function to run the effect to its completion and handle all effects generated by the initial effect. `redux-effect-reducer` comes with `TestMiddlewareContext` that provides an effect logger along with store dispatch logging. You can use your own `MiddlewareContext` if you like, but `TestMiddlewareContext` should support most needs.

Note: `runEffect()` will only execute the provided effect and its resulting effect tree. It will not respond to `dispatch()` effects (as this would require an effect reducer); you will have to set up a store with an effect reducer to do that.

```typescript
import isEqual from "lodash.isequal"
import { performance } from "perf_hooks";
(global as any).performance = performance;

function myEffect() {
    return run(async () => {
        await sleep(500)
        return dispatch({ type: "RUN_COMPLETED" })
    })
}

const context = new TestMiddlewareContext()
const effect = myEffect()
await runEffect(effect, context)

if (!isEqual(context.logger.last(), dispatch({ type: "RUN_COMPLETED" })) {
    fail()
}
```

### Testing with a store
Testing with a store is a little more tricky because there is no way to know when your effects have completed. Ideally, you will be able to test your effects, reducers, and effect reducers in isolation instead of having to rely on a full store setup for testing.

Testing synchronous effects will work as expected:
```typescript
import isEqual from "lodash.isequal"
import { performance } from "perf_hooks";
(global as any).performance = performance;

function reducer(state = { echoReceived: false }, action) {
    switch(action.type) {
        case "ECHO_RECEIVED":
            return {...state, { echoReceived: true }}
    }
}

function effectReducer(state, action) {
    switch(action.type) {
        case "ECHO":
            return dispatch({ type: "ECHO_RECEIVED" })
    }
}

const effectMiddleware = createEffectReducerMiddleware(effectReducer, { logger: logger })
const store = createStore(reducer, applyMiddleware(effectMiddleware))
store.dispatch({ type: "ECHO" })

if (logger.count() !== 1 ||
       !isEqual(logger.first().effect, dispatch({ type: "ECHO_RECEIVED" })) ||
        store.getState().echoReceived !== true){
    fail()
}
```

Testing asynchronous effects with a full store integration is uglier:
```typescript
import isEqual from "lodash.isequal"
import { performance } from "perf_hooks";
(global as any).performance = performance;

const logger = new DefaultEffectLogger()
const effectMiddleware = createEffectReducerMiddleware(effectReducer, { logger: logger })
const store = createStore(reducer, applyMiddleware(effectMiddleware))
store.dispatch({ type: "MY_ACTION" })
await sleep(5000) // Hopefully all asynchronous effects have completed by now

if (logger.count() > 20 || !isEqual(logger.last(), dispatch({ type: "EVERYTHING_DONE" })) {
    fail()
}